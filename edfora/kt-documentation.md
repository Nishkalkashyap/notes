---
title : KT-documentation
description : KT-documentation
tags : []
sidebar : false
pageClass: hide-sagar
---

# KT-documentation

[[toc]]

## Notes on Mypat frontend

### How we add webpack in Angular's build process
**Mypat frontend** is built on top of Angular 4, which does not has native support for injecting custom webpack config in the build process unlike Angular version 6+. We can use `ng eject` command to expose a custom webpack config but that comes with its own demerits. 

So to include webpack in our build process, we improvised and created our own way which works by modifying the `@angular/cli` package and changing angular's build scripts. 

To do this every time after a fresh `npm install` would be tedious, so we automated the process as follows:

1. We add a `postinstall` hook in our `package.json` file. This hook will run every time you run an `npm install` in the project.
    ```json
    "postinstall": "ts-node --skip-project ./scripts/generate-webpack-config.ts"
    ```
2. In the `postinstall` hook we run a script that modifies the angular's native build config and injects the path to our custom webpack config. The script looks as follows:

    ```ts
    // ./scripts/generate-webpack-config.ts
    import * as  fs from 'fs';

    const WEBPACK_CONFIG_PATH = './node_modules/@angular/cli/models/webpack-config.js';
    const baseWebpackConfig = fs.readFileSync(WEBPACK_CONFIG_PATH).toString();

    const stringToReplace = 'this.config = webpackMerge(webpackConfigs);';
    const newString = 'this.config = webpackMerge(webpackConfigs.concat(require(path.join(process.cwd(), "./base-webpack.config.js"))));';

    if (baseWebpackConfig.indexOf(stringToReplace) !== -1) {
        console.log('Injecting custom webpack config in angular');
        const replacedFile = baseWebpackConfig.replace(stringToReplace, newString);
        fs.writeFileSync(WEBPACK_CONFIG_PATH, replacedFile);
        console.log('Successfully injected custom webpack config in angular');
    } else {
        console.log('Config already injected');
    }
    ```
3. No we can export a webpack config from the path `./base-webpack.config.js`, which will be included by angular in development as well as build time.

!!! warning Gotcha!
The above works under the assumption that we are strictly using `@angular/cli` version `1.3.1`. If in future, we change the package version _(highly unlikely to happen unless we change angular version)_ to something other than this, this code will not work.
!!!

### How we add service worker
We add service worker in the website using the webpack plugin `workbox-webpack-plugin` in our webpack config. Mainly, we are using service worker for client side caching. Generating and using service worker works as follows:

1. At the build time, service worker and a precache manifest is generated by webpack.
2. In the `main.ts` file of the project, we include the service worker as follows:
    ```ts
    // ./src/main.ts
    function addServiceWorker() {
    navigator.serviceWorker.register('/service-worker.js').then(registration => {
        console.log('SW registered: ', registration);
    }).catch(registrationError => {
        console.log('SW registration failed: ', registrationError);
    });
    }
    ```
3. If need be, you can remove the service worker from the website with:
    ```ts
    // ./src/main.ts
    /**
     * The following will remove service worker and clear all associated caches
     * Use this for hard reset of website in case of dead-worker
     */
    function removeServiceWorker() {
        navigator.serviceWorker.getRegistrations().then(function (registrations) {
            for (const registration of registrations) {
                registration.unregister();
            }
            console.log('Service Worker unregistered successfully');
        }).catch((err) => {
            console.log('Service Worker failed to unregister', err);
        });

        // clearing cache
        caches.keys().then(function (names) {
            for (const name of names) {
            caches.delete(name);
            }
            console.log('Caches cleared successfully');
        }).catch((err) => {
            console.log('Failed to clear caches', err);
        });
    }
    ```

### How we handle image compression
At the time of the build, we do lossy image compression to compress the size of images, this is again done using webpack. Check out the rest of the config here - `./base-webpack.config.js`

## Notes on Documentation website
The idea of this documentation website is to bring all the technical documentation of the organization at one place. It is a statically built website and works on top of the `Vue.js` and `Vuepress` framework. Check out the getting started guide to see the development and build process. 

Here I share the deploy process, for the admins of this repo. The website will be deployed on `docs.mypat.org` bucket on S3, which is mapped through cloudflare DNS and makes the website accessible at `https://docs.mypat.org`.

### Setting the environment variables
Set the following environment variables in the project at `./docs/.env`
```
aws_access_key_id=
aws_secret_access_key=
```

### Deploy process
1. `git clone https://your-bitBucket-handle@bitbucket.org/edfora/documentation.git`
2. `cd ./documentation/docs`
3. `npm install`
4. `npm run build`
5. `npm run deploy`

### Restricting website access
Since the website could contain some confidential data and content of the organization, we implement an ip address access filter. Only the ones accessing the website through organization's internal internal IP will be able to access the website.

The IP address filter is implemented using `cloudflare workers` as follows:
```js
addEventListener('fetch', event => {
  event.respondWith(handleRequest(event.request))
});

async function handleRequest(request) {
    // Organization's internal IP address
    const edfora_internal_ip = '182.71.150.179';
    const request_ip = request.headers.get("cf-connecting-ip") || request.headers.get("cf-ipcountry");
    if (edfora_internal_ip == request_ip) {
        const response = await fetch(request);
        return response;
    }
    const res = new Response();
    res.status = 404;
    res.statusText = "Unauthorized";
    return res;
}
```

!!! note Note
The worker must be assigned a route to intercept, only then it works.
!!!

## Notes on cloudflare

### Adding DNS records
You can add DNS records in cloudflare by going into the DNS panel, The rest of the UI is pretty straight forward
![](/edfora/cf-2.jpg)

### Proxying a domain
To proxy a domain through cloudflare, click on the `cloud` icon as described in the image below. When the icon turns orange, this means that the domain is now proxied through cloudflare.
![](/edfora/cf-3.jpg)

!!! note Note
To enable DDoS mitigation, CND and other cloudflare features, you **must** proxy the records.
If you do not proxy a domain through cloudflare, cloudflare simply acts as a DNS resolver, and nothing more. 
!!!

### Cloudflare SSL type
Cloudflare has 4 different types of SSL encryption modes, **we have to** use the `Full` encryption mode, since we issue our own certificates through AWS certificate manager.
![](/edfora/cf-4.jpg)

!!! warning Warning
Any other mode of encryption could break the website in our case
!!!

### Optimizations
We use several optimization features of cloudflare. Check them out at the `Optimization` tab in the `Speed` section, as described in the image below.
![](/edfora/cf-5.jpg)

1. Auto Minification and Brotli Compression _(Keep them both turned on)_
    ![](/edfora/cf-6.jpg)
2. Rocket Loader _(Keep it enabled)_
    ![](/edfora/cf-7.jpg)

### Caching
1. Purging cache and cache level
    1. Use the `Purge Everything` option to purge cache from cloudflare, it may take up to 30 seconds to reflect.
    2. Use the `Standard` cache level, as we don't want to cache query strings
    ![](/edfora/cf-8.jpg)
2. Browser cache TTL, Always Online and development Mode
    1. **Browser cache ttl**: Currently, since are not setting `cache-control` headers on our server, we are using default caching policy of caching items for 4 hours. **This should be changed** and appropriate caching headers should be added from the server.
    2. **Always Online** <Badge text="Keep this on" type="tip"/>: Cloudflare will crawl our website _weekly_ and will cache the website, so that in case out server goes down, users are still able to see our website. **Keep this on**
    3. **Development mode** <Badge text="Keep this off" type="warning"/>: If you're pushing large number of commits in a short period of time, it can become tedious to clear cache every time. Enable this mode to disable caching while development. You would, for most of the time, **keep this off**
    ![](/edfora/cf-9.jpg)
